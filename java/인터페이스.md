## 인터페이스

### 인터페이스 vs 추상클래스

추상클래스

- **미완성 설계도**

- 추상 메서드(선언부만 작성하고 구현부는 작성하지 않는 메소드)를 선언하여 상속을 통해 자손 클래스에서 완성하도록 유도하는 클래스, 추상 메서드는 자식 클래스에 따라 달라질 수 있다.
- 추상 클래스내에 일반 메서드도 구현할 수 있다.
- 상속을 위한 클래스이기 때문에 객체를 생성할 수 없다

인터페이스

- **기본 설계도**
- 추상클래스처럼 다른 클래스를 작성하는데 도움을 주는 목적으로 작성
  - 객체를 생성할 수 없다
- 모든 메서드가 추상 메서드
  - 자바8부터 default 예약어를 통해 일반 메서드 구현이 가능하다
- 추상 클래스와 다르게 다중상속이 가능하다



### 인터페이스 만들기

```java
package javaStudy;

public interface TV {
    public int MIN_VOLUME=0;
    public int MAX_VOLUME=100;
    
    public void turnOn();
    public void turnoff();
    public void changeVolume(int volume);
    public void changeChannel(int channel);
}
```

- 인터페이스에는 추상 메소드와 상수를 정의할 수 있다.
  - 인터페이스에 정의된 메소드는 추상 클래스의 추상 메소드와 같이 구현부분이 없지만 `abstract` 키워드는 적어주지 않아도 된다.
  - **인터페이스에서 정의된 메소드는 모두 추상 메소드**이기 때문이다.
  - **인터페이스에서 변수를 선언하면 모두 상수**로 바뀐다.

컴파일 시 다음과 같이 변경된다.

```java
package javaStudy;

public interface TV {
    public static final int MAX_VOLUME = 100;
    public static final int MIN_VOLUME = 0;
    
    public abstract void turnOn();
    public abstract void trunoff();
    public abstract void changeVolume(int value);
    public abstract void changeChannel(int number);
}
```



### 인터페이스 사용하기

인터페이스를 사용할 때 해당 인터페이스를 구현하는 클래스에서 `implements` 키워드를 이용한다.

```java
package javaStudy;

public class LedTV implements TV { // TV 인터페이스를 구현하겠다.
    @Override
    public void turnOn() {
        
    }
    
    @Override
    public void turnoff() {
        
    }
    
    @Override
    public void changeVolume() {
        
    }
    
    @Override
    public void changeChannel() {
        
    }
    
}
```

- TV 인터페이스가 가진 모든 메소드를 LedTV 클래스가 구현해야한다.
- 참고로 메소드를 오버라이드할 때 `@Override`를 붙이는 편이 좋다고 한다.

```java
public class LedTVExam{
    public static void main(String args[]){
        TV tv = new LedTV();
        tv.on();
        tv.volume(50);
        tv.channel(6);
        tv.off();
    }
}
```

- **참조변수의 타입으로 인터페이스를 사용할 수 있다**. **이 경우 인터페이스가 가지고 있는 메소드만 사용할 수 있다.**



### Default 메소드

> Java8이 등장하면서 Interface에 대한 정의가 몇 가지 변경되었다.
>
> 기존 인터페이스는 추상 메서드만 가질 수 있었는데, Java8부터 default method, static method를 정의할 수 있게 되었다.

```java
package javaStudy;

public interface Caculator {
    public int plus(int i, int j);
    public int multiple(int i, int j);
    
    default int exec(int i, int j) { // 인터페이스에서도 메서드 구현이 가능?
        return i + j;
    }
}
```

- `default` 키워드를 통해 인터페이스에도 메서드 구현이 가능해졌다.

```java
package javaStudy;

public class MyCal implements Caculator { 
    
    @Override
    public int plus(int i, int j) {
        return i+j;
    }
    
    @Override
    public int multiple(int i, int j) {
        return i*j;
    }
}
```

- Caculator를 구현한 클래스 MyCal

```java
package javaStudy;

public class MyCalTest {
    
    public static void main(String[] args) {
        Caculator cal = new MyCal();
        cal.plus(3,4);
        cal.exec(5,6); // default method 사용 가능!
    }
}
```

- 인터페이스를 참조 변수로 가질 때, 인터페이스에 구현한 메서드를 사용할 수 있다.
- Java8에서 default method를 추가한 이유는, 
  - 본래 인터페이스는 클래스를 구현하기 위한 기본 설계도이기 때문에 인터페이스 설계 -> 클래스 구현의 순서로 개발 진행하는데
  - 클래스가 인터페이스를 구현한 이후에 인터페이스를 변경해야하는 경우가 발생할 수 도 있다.
  - 인터페이스가 변경되면 인터페이스를 구현하는 모든 클래스들이 해당 메소드를 구현해야하는 문제가 발생!
  - 따라서 인터페이스에 메소드를 구현할 수 있는 기능을 추가한 것이다.

- default 메소드도 인터페이스를 구현한 클래스에서 오버라이딩이 가능하다.



### Static 메소드

> Java8 부터 인터페이스에 `static` 키워드를 붙여 static 메소드를 구현할 수 있다.

```java
package javaStudy;

public interface Caculator {
    public int plus(int i, int j);
    public int multiple(int i, int j);
    
    default int exec(int i, int j) { 
        return i + j;
    }
    
    public static int exec2(int i, int j) {
        return i + j;
    }
}
```

- 인터페이스에서 정의한 static 메소드는 반드시 `인터페이스명.메소드명`으로 사용해야한다.

```java
package javaStudy;

public class MyCalTest {
    
    public static void main(String[] args) {
        Caculator cal = new MyCal();
        
        // cal.exec2(3,4); 참조변수로 사용할 수 없다.
        Caculator.exec2(3, 4);
    }
}
```

